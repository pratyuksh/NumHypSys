#include <gtest/gtest.h>

#include "mfem.hpp"
using namespace mfem;

#include <iostream>
#include <fstream>
#include <chrono>
#include <random>

#include <Eigen/Core>
#include <Eigen/Dense>

#include "../include/core/config.hpp"
#include "../include/core/error.hpp"


/* Test the H1-error computation,
 * implemented in class ComputeH1Error,
 * for quasi-uniform meshes,
 * generated by _serial_ code.
*/
TEST(Poisson, computeH1Error1) {

    std::string input_dir
            = "../input/poisson_smooth_unitSquare/";

    int lx1 = 2;
    int lx2 = 4;

    const std::string mesh_file1
            = input_dir+"mesh_lx"+std::to_string(lx1);
    const std::string sol_file1
            = input_dir+"sol_lx"+std::to_string(lx1);

    const std::string mesh_file2
            = input_dir+"mesh_lx"+std::to_string(lx2);
    const std::string sol_file2
            = input_dir+"sol_lx"+std::to_string(lx2);

    //std::cout << mesh_file1 << std::endl;
    //std::cout << mesh_file2 << std::endl;

    Mesh mesh1(mesh_file1.c_str());
    Mesh mesh2(mesh_file2.c_str());

    std::ifstream sol_ifs1(sol_file1.c_str());
    std::ifstream sol_ifs2(sol_file2.c_str());

    GridFunction u1(&mesh1, sol_ifs1);
    GridFunction u2(&mesh2, sol_ifs2);

    ComputeH1Error computeH1Error{};

    auto start1 = std::chrono::high_resolution_clock::now();
    auto [errorL21, u2L21, errorH101, u2H101]
            = computeH1Error(u1, u2);
    auto end1 = std::chrono::high_resolution_clock::now();

    auto start2 = std::chrono::high_resolution_clock::now();
    auto [errorL22, u2L22, errorH102, u2H102]
            = computeH1Error.test_slow(u1, u2);
    auto end2 = std::chrono::high_resolution_clock::now();

    double TOL = 1E-8;
    ASSERT_LE((errorL21/u2L21 - errorL22/u2L22), TOL);
    ASSERT_LE((errorH101/u2H101 - errorH102/u2H102), TOL);

    auto duration1 = std::chrono::duration_cast
            <std::chrono::microseconds>(end1 - start1);
    auto duration2 = std::chrono::duration_cast
            <std::chrono::microseconds>(end2 - start2);

    std::cout << "Relative L2 error: "
              << errorL21/u2L21 << "\t"
              << errorL22/u2L22 << std::endl;
    std::cout << "Relative H10 error: "
              << errorH101/u2H101 << "\t"
              << errorH102/u2H102 << std::endl;
    std::cout << "Run times: "
              << "\t fast  " << duration1.count()
              << "\t slow  " << duration2.count()
            << std::endl;
}

/* Test the H1-error computation,
 * implemented in class ComputeH1Error,
 * for meshes with local refinement,
 * generated by _serial_ code.
*/
TEST(Poisson, computeH1Error2) {

    std::string input_dir
            = "../input/"
              "poisson_singular_gammaShaped_bisecRefine/";

    int lx1 = 2;
    int lx2 = 4;

    const std::string mesh_file1
            = input_dir+"mesh_lx"+std::to_string(lx1);
    const std::string sol_file1
            = input_dir+"sol_lx"+std::to_string(lx1);

    const std::string mesh_file2
            = input_dir+"mesh_lx"+std::to_string(lx2);
    const std::string sol_file2
            = input_dir+"sol_lx"+std::to_string(lx2);

    //std::cout << mesh_file1 << std::endl;
    //std::cout << mesh_file2 << std::endl;

    Mesh mesh1(mesh_file1.c_str());
    Mesh mesh2(mesh_file2.c_str());

    std::ifstream sol_ifs1(sol_file1.c_str());
    std::ifstream sol_ifs2(sol_file2.c_str());

    GridFunction u1(&mesh1, sol_ifs1);
    GridFunction u2(&mesh2, sol_ifs2);

    ComputeH1Error computeH1Error{};

    auto start1 = std::chrono::high_resolution_clock::now();
    auto [errorL21, u2L21, errorH101, u2H101]
            = computeH1Error(u1, u2);
    auto end1 = std::chrono::high_resolution_clock::now();

    auto start2 = std::chrono::high_resolution_clock::now();
    auto [errorL22, u2L22, errorH102, u2H102]
            = computeH1Error.test_slow(u1, u2);
    auto end2 = std::chrono::high_resolution_clock::now();

    double TOL1 = 1E-6;
    double TOL2 = 1E-5;
    ASSERT_LE((errorL21/u2L21 - errorL22/u2L22), TOL1);
    ASSERT_LE((errorH101/u2H101 - errorH102/u2H102), TOL2);

    auto duration1 = std::chrono::duration_cast
            <std::chrono::microseconds>(end1 - start1);
    auto duration2 = std::chrono::duration_cast
            <std::chrono::microseconds>(end2 - start2);

    std::cout << "Relative L2 error: "
              << errorL21/u2L21 << "\t"
              << errorL22/u2L22 << std::endl;
    std::cout << "Relative H10 error: "
              << errorH101/u2H101 << "\t"
              << errorH102/u2H102 << std::endl;
    std::cout << "Run times: "
              << "\t fast  " << duration1.count()
              << "\t slow  " << duration2.count()
            << std::endl;
}

/* Test the H1-error computation,
 * implemented in class ComputeH1Error,
 * for quasi-uniform meshes,
 * generated by _parallel_ code.
*/
TEST(Poisson, computeH1Error3) {

    std::string input_dir
            = "../input/poisson_smooth_unitSquare/";

    int lx1 = 2;
    int lx2 = 4;

    const std::string mesh_file1
            = input_dir+"mesh_lx"+std::to_string(lx1);
    const std::string sol_file1
            = input_dir+"sol_lx"+std::to_string(lx1);

    const std::string mesh_file2
            = input_dir+"mesh_lx"+std::to_string(lx2);
    const std::string sol_file2
            = input_dir+"sol_lx"+std::to_string(lx2);

    const std::string mesh_file1p
            = input_dir+"pmesh_lx"+std::to_string(lx1);
    const std::string sol_file1p
            = input_dir+"psol_lx"+std::to_string(lx1);

    const std::string mesh_file2p
            = input_dir+"pmesh_lx"+std::to_string(lx2);
    const std::string sol_file2p
            = input_dir+"psol_lx"+std::to_string(lx2);

    Mesh mesh1(mesh_file1.c_str());
    Mesh mesh2(mesh_file2.c_str());
    Mesh mesh1p(mesh_file1.c_str());
    Mesh mesh2p(mesh_file2.c_str());

    std::ifstream sol_ifs1(sol_file1.c_str());
    std::ifstream sol_ifs2(sol_file2.c_str());
    std::ifstream sol_ifs1p(sol_file1.c_str());
    std::ifstream sol_ifs2p(sol_file2.c_str());

    GridFunction u1(&mesh1, sol_ifs1);
    GridFunction u2(&mesh2, sol_ifs2);
    GridFunction u1p(&mesh1p, sol_ifs1p);
    GridFunction u2p(&mesh2p, sol_ifs2p);

    ComputeH1Error computeH1Error{};

    auto start1 = std::chrono::high_resolution_clock::now();
    auto [errorL21, u2L21, errorH101, u2H101]
            = computeH1Error(u1, u2);
    auto end1 = std::chrono::high_resolution_clock::now();

    bool has_shared_vertices = true;
    auto start2 = std::chrono::high_resolution_clock::now();
    auto [errorL22, u2L22, errorH102, u2H102]
            = computeH1Error(u1p, u2p, has_shared_vertices);
    auto end2 = std::chrono::high_resolution_clock::now();

    double TOL = 1E-8;
    ASSERT_LE((errorL21/u2L21 - errorL22/u2L22), TOL);
    ASSERT_LE((errorH101/u2H101 - errorH102/u2H102), TOL);

    auto duration1 = std::chrono::duration_cast
            <std::chrono::microseconds>(end1 - start1);
    auto duration2 = std::chrono::duration_cast
            <std::chrono::microseconds>(end2 - start2);

    std::cout << "Relative L2 error: "
              << errorL21/u2L21 << "\t"
              << errorL22/u2L22 << std::endl;
    std::cout << "Relative H10 error: "
              << errorH101/u2H101 << "\t"
              << errorH102/u2H102 << std::endl;
    std::cout << "Run times: "
              << "\t fast  " << duration1.count()
              << "\t slow  " << duration2.count()
            << std::endl;
}

/* Test the H1-error computation,
 * implemented in class ComputeH1Error,
 * for meshes with local refinement,
 * generated by _serial_ code.
*/
TEST(Poisson, computeH1Error4) {

    std::string input_dir
            = "../input/"
              "poisson_singular_gammaShaped_bisecRefine/";

    int lx1 = 2;
    int lx2 = 4;

    const std::string mesh_file1
            = input_dir+"mesh_lx"+std::to_string(lx1);
    const std::string sol_file1
            = input_dir+"sol_lx"+std::to_string(lx1);

    const std::string mesh_file2
            = input_dir+"mesh_lx"+std::to_string(lx2);
    const std::string sol_file2
            = input_dir+"sol_lx"+std::to_string(lx2);

    const std::string mesh_file1p
            = input_dir+"pmesh_lx"+std::to_string(lx1);
    const std::string sol_file1p
            = input_dir+"psol_lx"+std::to_string(lx1);

    const std::string mesh_file2p
            = input_dir+"pmesh_lx"+std::to_string(lx2);
    const std::string sol_file2p
            = input_dir+"psol_lx"+std::to_string(lx2);

    Mesh mesh1(mesh_file1.c_str());
    Mesh mesh2(mesh_file2.c_str());
    Mesh mesh1p(mesh_file1.c_str());
    Mesh mesh2p(mesh_file2.c_str());

    std::ifstream sol_ifs1(sol_file1.c_str());
    std::ifstream sol_ifs2(sol_file2.c_str());
    std::ifstream sol_ifs1p(sol_file1.c_str());
    std::ifstream sol_ifs2p(sol_file2.c_str());

    GridFunction u1(&mesh1, sol_ifs1);
    GridFunction u2(&mesh2, sol_ifs2);
    GridFunction u1p(&mesh1p, sol_ifs1p);
    GridFunction u2p(&mesh2p, sol_ifs2p);

    ComputeH1Error computeH1Error{};

    auto start1 = std::chrono::high_resolution_clock::now();
    auto [errorL21, u2L21, errorH101, u2H101]
            = computeH1Error(u1, u2);
    auto end1 = std::chrono::high_resolution_clock::now();

    bool has_shared_vertices = true;
    auto start2 = std::chrono::high_resolution_clock::now();
    auto [errorL22, u2L22, errorH102, u2H102]
            = computeH1Error(u1p, u2p, has_shared_vertices);
    auto end2 = std::chrono::high_resolution_clock::now();

    double TOL = 1E-8;
    ASSERT_LE((errorL21/u2L21 - errorL22/u2L22), TOL);
    ASSERT_LE((errorH101/u2H101 - errorH102/u2H102), TOL);

    auto duration1 = std::chrono::duration_cast
            <std::chrono::microseconds>(end1 - start1);
    auto duration2 = std::chrono::duration_cast
            <std::chrono::microseconds>(end2 - start2);

    std::cout << "Relative L2 error: "
              << errorL21/u2L21 << "\t"
              << errorL22/u2L22 << std::endl;
    std::cout << "Relative H10 error: "
              << errorH101/u2H101 << "\t"
              << errorH102/u2H102 << std::endl;
    std::cout << "Run times: "
              << "\t fast  " << duration1.count()
              << "\t slow  " << duration2.count()
            << std::endl;
}
